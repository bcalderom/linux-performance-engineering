# 1.3 Programs, Processes and Threads

## Key Terms

- **Program**: A file on disk that contains executable code (for example, `/usr/bin/ls` or `/bin/bash`). It is *not* running yet; it is just bytes stored in a file.
- **Process**: A **running instance** of a program with its own memory, open files, and execution state. The OS tracks each process with a unique **PID**.
- **Thread**: A path of execution inside a process. Multiple threads in the same process share the **same memory and open files**.
- **PID (Process ID)**: A unique numeric identifier assigned by the kernel to each running process.
- **PPID (Parent Process ID)**: The PID of the **parent process** that created a given process.

---

## 1.3.1 Programs vs Processes

A useful analogy:

- A **program** is like a **recipe** in a cookbook.
- A **process** is like a **dish being cooked right now** using that recipe.

On disk:

- `/usr/bin/sleep` is a program.

In memory:

- When you run `sleep 60`, the OS creates a **process** that executes the code in `/usr/bin/sleep` for 60 seconds.

You can have many processes from the same program, for example:

```bash
sleep 100 &
sleep 200 &
```

Both are running the `sleep` program, but they are **different processes** with different PIDs and lifetimes.

---

## 1.3.2 Seeing Processes with `ps`

Run:

```bash
ps -o pid,ppid,comm,state
```

Typical columns:

- `PID` – Process ID.
- `PPID` – Parent process ID.
- `COMMAND` (or `COMM`) – Program name.
- `STAT` / `STATE` – Process state (R, S, D, Z, etc.).

Example: start a process and inspect it.

```bash
sleep 300 &
ps -o pid,ppid,comm,state -p $!
```

Here:

- `$!` is the PID of the most recent background command.
- You can see the `PID`, `PPID`, and `STATE` for that `sleep` process.

This is your first practical way to **map what you started in the shell to a process the OS is managing**.

---

## 1.3.3 What Are Threads?

So far we have considered one process doing one thing at a time. Many applications use **multiple threads** inside a single process to do more work in parallel (for example, a web server handling many connections).

Key properties:

- All threads in a process **share the same memory**.
- They also share open files, network sockets, and other resources.
- The scheduler treats threads as units of work when deciding what runs on each CPU.

You can see threads with:

```bash
ps -L -p $$ -o pid,tid,ppid,comm
```

Where:

- `PID` is the process ID.
- `TID` is the thread ID (often equal to PID for the main thread).

Tools like `top -H` show threads individually, which becomes important when debugging **per-thread CPU usage**.

---

## 1.3.4 Parent and Child Processes

Processes generally come from **other processes**. Your shell spawned by your login/session creates child processes whenever you run a command.

Example:

```bash
ps -o pid,ppid,comm | head
```

You will usually see that:

- Your shell’s `PPID` is a login manager or `systemd`.
- Commands you run (like `sleep`, `ls`) have their `PPID` equal to your shell’s `PID`.

Understanding parent/child relationships will matter later when tracking **process trees** and **service hierarchies** under `systemd`.

---

## 1.3.5 Hands-On: Programs, Processes, and Threads

Run these examples on a non-production machine.

### Exercise 1 – One Program, Multiple Processes

1. Start two `sleep` commands in the background:

   ```bash
   sleep 100 &
   sleep 200 &
   ```

2. List them:

   ```bash
   ps -o pid,ppid,comm,state | grep sleep | grep -v grep
   ```

Questions:

- How many different PIDs do you see for `sleep`?
- Are their `PPID` values the same?

### Exercise 2 – Inspect Your Shell’s Threads

1. Find your shell’s PID:

   ```bash
   echo $$
   ```

2. Inspect threads for your shell process:

   ```bash
   ps -L -p $$ -o pid,tid,ppid,comm
   ```

On many systems you will see at least one thread (TID equal to PID). More complex shells or environments may show additional threads.

### Exercise 3 – Use `top -H` to View Threads

1. In one terminal, start a CPU-bound loop (keep it short and safe):

   ```bash
   ( while true; do :; done ) &
   ```

2. In another terminal, run:

   ```bash
   top -H -p <PID-of-the-loop-shell>
   ```

You will see per-thread CPU usage, which becomes vital later when debugging multi-threaded applications.

---

## Beginner Checklist

By the end of this chapter, you should be able to:

- [ ] Distinguish between a **program** (file on disk) and a **process** (running instance of that program).
- [ ] Find the PID and PPID of a running process using `ps`.
- [ ] Explain what a **thread** is and why multi-threading can improve throughput.
- [ ] Use simple commands (`sleep`, `ps`, `top -H`) to observe processes and threads on a Linux system.

