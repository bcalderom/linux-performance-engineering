# 1.2 The Shell and Commands

## Key Terms

- **Shell**: An interactive program (such as `bash`, `zsh`, or `fish`) that reads your commands, interprets them, and asks the kernel to start the corresponding programs.
- **Command**: What you type into the shell. It usually consists of a program name plus **arguments** and sometimes **options** (e.g., `ls -l /var/log`).
- **Standard input (stdin)**: A stream of data a program can read from (by default, your keyboard).
- **Standard output (stdout)**: A stream of data a program writes normal output to (by default, your terminal).
- **Standard error (stderr)**: A stream of data a program writes error messages to (also your terminal by default).

---

## 1.2.1 What Is the Shell?

You can think of the shell as a **command interpreter**:

1. It prints a **prompt** (e.g., `$`).
2. You type a line of text.
3. It parses that line into a **command** and its **arguments**.
4. It asks the kernel to run that command as a **process**.
5. It waits for the command to finish (unless told to run it in the background).

From a performance point of view, the shell is how humans and scripts **create processes and workloads** on the system. Every CPU-intensive job or diagnostic you run usually starts with a shell command.

---

## 1.2.2 Simple Commands and Output

Try a few fundamental commands:

```bash
echo "hello world"
ls
pwd
```

- `echo` prints text to **stdout**.
- `ls` lists files in the current directory.
- `pwd` prints the current working directory.

Behind the scenes:

- The shell finds the executable (using the `PATH` environment variable).
- It tells the kernel to create a new process to run that program.
- The kernel runs it and wires up its stdin, stdout, and stderr.

---

## 1.2.3 Pipelines and Redirection

The shell lets you **chain commands** and redirect data between them.

### Redirection

```bash
echo "log message" > example.log
cat example.log
```

- `>` redirects **stdout** to a file instead of the terminal.
- `cat example.log` reads the file back and prints it to stdout.

### Pipelines

```bash
ls /usr/bin | head
```

- `|` (pipe) connects the stdout of `ls` to the stdin of `head`.
- The shell sets up this connection, but the kernel actually moves the data.

Performance angle:

- Pipelines and redirection are lightweight and efficient ways to process data without writing intermediate files.

---

## 1.2.4 Exit Status and Errors

Every command returns an **exit status** (also called **exit code**):

- `0` usually means **success**.
- Non-zero values usually mean **failure** or a specific error.

In the shell, you can check the last exit status using `$?`:

```bash
true
echo $?

false
echo $?
```

Expected behavior:

- `true` prints nothing but returns exit status `0`.
- `false` prints nothing but returns a non-zero status (often `1`).

Scripts and automation heavily rely on exit status to detect failures.

---

## 1.2.5 From Command to Process (High-Level Flow)

When you run:

```bash
ls /tmp
```

The sequence is roughly:

1. The **shell** parses the command line into program `ls` and argument `/tmp`.
2. The shell looks up `ls` in the `PATH` (for example `/usr/bin/ls`).
3. The shell calls the kernel (via system calls) to **create a new process** running `/usr/bin/ls`.
4. The kernel schedules that process on a CPU core.
5. `ls` runs, reads `/tmp`, and writes results to stdout.
6. The kernel delivers the output back to your terminal.

You don’t see these steps, but understanding them is crucial later when you:

- Trace **slow commands**.
- Connect CPU usage back to the commands that generated it.
- Understand how many processes your workload actually creates.

---

## 1.2.6 Hands-On: Exploring the Shell

Run these commands on a non-production machine.

### Step 1 – Identify Your Shell

```bash
echo $SHELL
ps -p $$ -o pid,ppid,comm
```

Questions:

- What shell are you using (e.g., `/bin/bash`, `/bin/zsh`)?
- What is the command name shown for your shell process?

### Step 2 – Experiment with Redirection and Pipes

```bash
ls /usr/bin > bin-list.txt
wc -l bin-list.txt

ls /usr/bin | wc -l
```

Compare:

- `>` created an intermediate file.
- The pipeline avoided writing a file at all.

### Step 3 – See Exit Status in Action

```bash
ls /this/path/does/not/exist
echo "exit status was: $?"
```

Observe that the command fails and `$?` is non-zero. This pattern is a building block for robust scripts.

---

## Beginner Checklist

By the end of this chapter, you should be able to:

- [ ] Explain what a shell is and name at least one shell you have used.
- [ ] Run basic commands (`echo`, `ls`, `pwd`) and understand where their output goes.
- [ ] Use simple redirection and pipelines (`>`, `|`) to combine commands.
- [ ] Check and interpret the exit status of the last command using `$?`.
- [ ] Describe at a high level what happens when you press Enter on a command.
