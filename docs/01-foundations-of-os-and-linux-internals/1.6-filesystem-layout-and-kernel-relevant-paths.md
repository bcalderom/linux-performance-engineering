# 1.6 Filesystem Layout & Kernel-Relevant Paths

## Key Terms

- **Filesystem**: An organized way the OS stores and names files and directories on storage devices.
- **/proc**: A virtual filesystem that exposes live kernel and process information as files.
- **/sys (sysfs)**: A virtual filesystem that exposes kernel objects and tunable settings, often per device.
- **/var/log**: Directory tree where system and application logs are stored.
- **/run**: In-memory filesystem for volatile runtime state (PID files, sockets, small lock files).
- **Virtual filesystem**: A filesystem whose contents are generated on the fly by the kernel rather than stored on disk.

## Purpose and Scope

This document explains **where Linux exposes kernel and system state** and where important logs and runtime data live. You will learn to navigate:

- `/proc` – real-time kernel and process information.
- `/sys` – kernel objects and tunables via sysfs.
- `/var/log` – persistent logs.
- `/run` – volatile runtime state.

Understanding these paths is essential for diagnosing performance issues and feeding observability pipelines.

The helper script `scripts/section01-06-proc-and-sys-explorer.sh` automates several examples in this document.

---

## 1.6.1 High-Level Filesystem Layout

Most Linux systems roughly follow the **Filesystem Hierarchy Standard (FHS)**. From a performance engineer’s perspective, some directories matter more than others:

- `/` – root of the filesystem hierarchy.
- `/bin`, `/usr/bin` – user commands.
- `/sbin`, `/usr/sbin` – system administration commands.
- `/etc` – configuration.
- `/home` – user home directories.
- `/var` – variable data (logs, queues, spool).
- `/proc` – pseudo-files exposing kernel and process state.
- `/sys` – pseudo-files exposing kernel objects and tunables.
- `/run` – volatile runtime data (PID files, sockets, locks).

We will focus on `/proc`, `/sys`, `/var/log`, and `/run`.

---

## 1.6.2 /proc – Kernel and Process Information

`/proc` is a **virtual filesystem**. Files in `/proc` do not live on disk; they are generated on the fly by the kernel when read.

### Process-Specific Directories

Each PID gets a directory:

- `/proc/<pid>/` – contains files that describe that process.

Examples:

- `/proc/<pid>/cmdline` – command-line arguments.
- `/proc/<pid>/status` – high-level stats (memory, state, capabilities).
- `/proc/<pid>/limits` – resource limits.
- `/proc/<pid>/fd/` – open file descriptors.

Inspect your shell process:

```bash
echo $$            # shell PID
ls /proc/$$
cat /proc/$$/status | head
```

Performance usage:

- Check whether a process is near resource limits (open files, max processes).
- Inspect memory usage details, threads, NUMA policy, etc.

### System-Wide Kernel Information

Some key files:

- `/proc/cpuinfo` – CPU model, flags, cores, cache sizes.
- `/proc/meminfo` – detailed memory breakdown.
- `/proc/uptime` – seconds since boot and idle time.
- `/proc/loadavg` – load averages.
- `/proc/interrupts` – interrupt counters per CPU.
- `/proc/softirqs` – softirq counters per CPU.

Example:

```bash
cat /proc/meminfo | head
cat /proc/loadavg
cat /proc/interrupts | head
```

**Interpretation hints:**

- `MemAvailable` in `/proc/meminfo` is usually a better indicator of free memory than `MemFree`.
- High counts in specific interrupt lines can hint at **hot NICs or storage devices**.

### Visualization

```mermaid
flowchart TD
    K[Linux Kernel] -->|exposes| PROC[/proc filesystem]
    PROC --> PINFO[Process-specific data]
    PROC --> SYSINFO[System-wide stats]

    APP[Diagnostic Tools] -->|read()| PROC
```

Tools like `ps`, `top`, `htop`, `vmstat`, and `pidstat` ultimately consume `/proc` data, even if indirectly.

---

## 1.6.3 /sys – Kernel Objects and Tunables

`/sys` (sysfs) exposes **kernel objects** (devices, drivers, subsystems) in a hierarchical structure. Many files here are **writable** and reflect kernel tunables.

Examples:

- `/sys/class/net/` – network interfaces.
- `/sys/block/` – block devices (disks, SSDs).
- `/sys/devices/system/cpu/` – CPU-related settings, including scaling.

Inspect network interfaces:

```bash
ls /sys/class/net
cat /sys/class/net/lo/mtu
```

Inspect CPU frequency governor (if supported):

```bash
ls /sys/devices/system/cpu/cpu0/cpufreq
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null || echo "No cpufreq on this CPU"
```

**Warning:** Many files in `/sys` are writable. Changing them affects kernel behavior **immediately**. For now, treat `/sys` as **read-only** unless you know exactly what you are doing.

From a performance standpoint, `/sys` is where you will eventually:

- Pin interrupts and CPUs.
- Adjust power management policies.
- View device queues and driver-specific stats.

---

## 1.6.4 /var/log – Logs

`/var/log` contains log files written by the kernel, system services, and applications. Exact filenames depend on distribution and logging stack.

Typical logs:

- `syslog` or `messages` – general system log.
- `kern.log` – kernel-specific messages (sometimes merged into `syslog`).
- Service-specific logs (e.g., `nginx`, `mysql`).

Inspect recent kernel-related messages:

```bash
sudo dmesg | tail -n 20
```

or (depending on distro and logger):

```bash
sudo grep -Ei 'error|fail|warn' /var/log/* 2>/dev/null | head
```

Performance relevance:

- Storage timeouts, I/O errors, link flaps, driver resets all typically show up here first.
- During incidents, you should **always** correlate metrics with logs from `/var/log` and `journalctl`.

---

## 1.6.5 /run – Runtime State

`/run` is a **tmpfs (in-memory filesystem)** that holds volatile runtime data:

- PID files.
- UNIX domain sockets.
- Locks and small state files.

Example:

```bash
mount | grep ' /run '
ls /run
```

Performance considerations:

- Because `/run` is tmpfs, access is typically fast.
- However, misuse (very large runtime files, poor cleanup) can still create memory pressure.

Some services store their communication sockets here; a full or corrupted `/run` can prevent daemons from starting correctly.

---

## 1.6.6 Failure Scenarios and Diagnostics

### Scenario A – High Interrupt or SoftIRQ Load

Symptoms:

- High CPU usage in `ksoftirqd` or interrupt context (seen in later CPU/network chapters).
- Packet drops or elevated network latency.

`/proc` vantage point:

```bash
cat /proc/interrupts | head
cat /proc/softirqs
```

Interpretation (high-level preview):

- Interrupts and **softirqs** are how the kernel reacts to hardware events (like incoming packets) and defers some of the work. You can think of them as short, high-priority tasks the kernel must run on CPUs.
- Rapidly increasing counts on a subset of CPUs or for a particular IRQ line suggest a **hot interrupt source**.
- Imbalanced traffic can be tied back to specific NIC queues.

### Scenario B – Storage Issues

Symptoms:

- Many tasks in `D` state.
- High I/O wait in tools like `iostat`.

Check logs:

```bash
sudo dmesg | grep -Ei 'error|fail|timeout|reset' | tail -n 20
sudo grep -Ei 'error|fail|timeout|reset' /var/log/* 2>/dev/null | head
```

Look for:

- Disk or controller resets.
- NFS timeouts.
- Filesystem errors and remounts.

### Scenario C – Misconfigured or Missing Runtime State

Symptoms:

- Services fail to start due to missing PID file directories or stale sockets.

Check `/run`:

```bash
ls -R /run | head
```

Correlate with service unit definitions to see where they expect PID files and sockets.

---

## 1.6.7 Hands-On Exercises

These exercises use both manual exploration and the helper script `scripts/section01-06-proc-and-sys-explorer.sh`.

### Exercise 1 – Explore /proc for System-Wide Information

1. Run:
   ```bash
   cat /proc/meminfo | head
   cat /proc/cpuinfo | head
   cat /proc/loadavg
   ```
2. Identify:
   - Total memory, `MemAvailable`, and `SwapTotal`.
   - CPU model and number of cores.
   - Current load averages.

### Exercise 2 – Explore /proc for a Single Process

1. In a shell, note your PID:
   ```bash
   echo $$
   ```
2. Inspect:
   ```bash
   ls /proc/$$
   cat /proc/$$/status | head
   ls -l /proc/$$/fd | head
   ```

Questions:

- How many open file descriptors do you have?
- What is the process state in `/proc/$$/status`?

### Exercise 3 – Explore /sys and Network Interfaces

1. List network interfaces via sysfs:
   ```bash
   ls /sys/class/net
   ```
2. For a chosen interface (e.g., `eth0` or `ens3`):
   ```bash
   cat /sys/class/net/<iface>/mtu
   cat /sys/class/net/<iface>/speed 2>/dev/null || echo "Speed not exposed via sysfs"
   ```

**Hint:** MTU and link speed are critical for understanding network throughput and fragmentation problems.

### Exercise 4 – Use the Helper Script

Run:

```bash
bash scripts/section01-06-proc-and-sys-explorer.sh
```

The script will:

- Dump key fields from `/proc/meminfo`, `/proc/cpuinfo`, and `/proc/loadavg`.
- Show a sample process directory from `/proc/<pid>`.
- Enumerate network interfaces and selected attributes from `/sys/class/net`.

Map each piece of output back to the concepts explained above.

---

## 1.6.8 Beginner Checklist

By the end of this chapter, you should be able to:

- [ ] Identify which directories are most relevant for **kernel state** and **diagnostics** (`/proc`, `/sys`, `/var/log`, `/run`).
- [ ] Use `/proc` to obtain detailed information about **memory**, **CPUs**, and **processes**.
- [ ] Explain at a high level how `/sys` exposes kernel objects and tunables and why it must be handled carefully.
- [ ] Locate and inspect logs under `/var/log` and runtime state under `/run` when diagnosing failures and startup issues.
