# 11.1 Nice and CPU Priority

## Key Terms

- **Nice value (`nice`)**: A per-process setting that tells the scheduler how "polite" a task should be. Higher values make a task yield more CPU time to others; lower values let it claim more CPU time.
- **Priority**: A relative indication of how important a task is to the scheduler compared to others.
- **Scheduler**: The kernel component that decides which process or thread runs on which CPU and for how long.
- **Runqueue**: The per-CPU list of runnable tasks waiting to be scheduled.
- **CPU-bound task**: A task that spends most of its time doing computations on the CPU rather than waiting for I/O.
- **I/O-bound task**: A task that spends most of its time waiting for I/O (disk, network) rather than using the CPU.

## 11.1.1 What Is `nice`?

On Linux, every process has a **nice value**, often just called "nice". It is a number that expresses **how willing that process is to give up CPU time** to other processes:

- Higher nice (e.g., `+10`) → the process is *more polite*, and the scheduler gives it **less** CPU share.
- Lower nice (e.g., `-10`) → the process is *less polite*, and the scheduler gives it **more** CPU share.

You can think of `nice` as a **hint to the scheduler** about relative importance. It does *not* guarantee absolute priority, but it strongly influences how much CPU time a process gets compared to others.

### Everyday Analogy

Imagine a single checkout line at a supermarket:

- Everyone in line will eventually get served.
- Some people are in a hurry and others are relaxed.
- If relaxed people agree to let others move ahead, they effectively have a **higher nice** value.

In Linux terms:

- A relaxed customer is a **high nice** process (willing to wait, gets less CPU).
- A customer in a hurry is a **low nice** process (wants to be served sooner, gets more CPU).

## 11.1.2 How `nice` Interacts with the Scheduler

Under the default Linux scheduler for normal tasks (CFS – **Completely Fair Scheduler**), the kernel tries to give each runnable task a **fair share of CPU time** over the long run.

`nice` influences that fairness calculation:

- Tasks with **lower nice** are treated as more important and accumulate CPU time faster.
- Tasks with **higher nice** accumulate CPU time more slowly and are picked less often when the CPU is busy.

Important points for a sysadmin/SRE:

- `nice` is **per-process (and per-thread)**.
- Changing the nice value affects how a process **competes for CPU** but does **not** change its I/O priority, memory priority, or network priority.
- `nice` matters the most when the CPU is **contended** (many runnable tasks).

## 11.1.3 Ranges and Defaults

On most Linux systems:

- Nice values range from **-20** (highest priority) to **+19** (lowest priority).
- Normal processes usually start at **0** unless changed by the user or a service manager like `systemd`.

Summary of the range:

- `-20` → as aggressive as possible (avoid this unless you really mean it).
- `0` → default importance.
- `+19` → as polite as possible; only runs when CPU is otherwise idle.

## 11.1.4 Inspecting Nice Values

You can see the nice value of processes using `ps` or `top`.

### With `ps`

```bash
ps -o pid,ni,comm --sort=ni | head
```

- `PID` – Process ID.
- `NI` – Nice value.
- `COMMAND` – Program name.

Questions to ask:

- Which processes are running with a **negative** nice (higher priority)?
- Which ones have **very high positive** nice values and will get CPU only when the machine is otherwise idle?

### With `top`

Run:

```bash
top
```

Look for the `NI` column:

- `0` – default nice.
- Positive values – polite tasks.
- Negative values – high-priority tasks.

## 11.1.5 Changing Nice Values Safely

You typically change nice values with two tools:

- `nice` – start a new command with a specific nice value.
- `renice` – adjust the nice value of an existing process.

### Starting a Command with `nice`

```bash
nice -n 10 long_running_job.sh
```

- Starts `long_running_job.sh` with a nice value of `+10`.
- This makes it more polite and less likely to interfere with interactive work.

Common pattern:

- Use **positive** nice values to lower the CPU priority of batch jobs, backups, large data processing tasks, etc.

### Adjusting an Existing Process with `renice`

```bash
ps -o pid,ni,comm | grep myjob
sudo renice -n 10 -p <PID>
```

- `renice -n 10 -p <PID>` sets that process to nice `+10`.
- Lowering nice below 0 (e.g., `-5`) often requires root privileges.

**Warning:** Be careful when giving processes **negative** nice values:

- They can starve other workloads of CPU time.
- They can make the system feel sluggish if misused.

## 11.1.6 When `nice` Helps (and When It Doesnt)

`nice` is particularly useful when you:

- Run **CPU-bound batch jobs** (compression, large builds, analytics) on shared machines.
- Want your **interactive shells and editors** to remain responsive.

Good use cases:

- Run nightly report generation or indexing with a higher nice (e.g., `+10`).
- Keep monitoring agents or critical services closer to default or slightly negative nice.

Limitations:

- `nice` does **not** fix I/O bottlenecks (disk, network) or memory pressure.
- A task stuck in `D` state (uninterruptible sleep) is **waiting for I/O**, and changing its nice value will not unblock it.
- If the machine is heavily I/O-bound or swapping, `nice` may have little visible effect.

## 11.1.7 Practical Exercise: Seeing `nice` in Action

Run these on a **test system** or disposable VM.

### Step 1 – Start a CPU-Bound Job with Default Nice

```bash
( while true; do :; done ) &
ps -o pid,ni,pcpu,comm -p $!
```

- This starts a simple CPU burner in the background.
- Observe that `NI` is `0` and `%CPU` is close to 100% on one core.

### Step 2 – Start a Second Job with Higher Nice

In another terminal, run:

```bash
nice -n 10 sh -c 'while true; do :; done' &
ps -o pid,ni,pcpu,comm | grep 'sh -c'
```

- This second loop runs with nice `+10`.
- Use `top` and watch the `%CPU` and `NI` columns for both loops.

Questions:

- Does the `+10` job get **less CPU** than the `0`-nice job?
- How does this change when the system has more or fewer other tasks running?

### Step 3 – Adjusting Nice with `renice`

Pick one of the loops and run:

```bash
sudo renice -n 15 -p <PID-of-loop>
ps -o pid,ni,pcpu,comm -p <PID-of-loop>
```

- Verify that `NI` changed to `15`.
- Observe over time how its CPU usage compares to the other loop.

When done, stop the loops with `kill`:

```bash
kill <PID1> <PID2>
```

## 11.1.8 Beginner Checklist

By the end of this appendix, you should be able to:

- [ ] Explain what the **nice value** is and how it affects CPU sharing.
- [ ] Inspect nice values of running processes using `ps` or `top`.
- [ ] Start a new command with a specific nice value using `nice`.
- [ ] Change the nice value of an existing process using `renice`.
- [ ] Decide when adjusting `nice` is appropriate, and when CPU issues are better addressed elsewhere (I/O, memory, or application behavior).
